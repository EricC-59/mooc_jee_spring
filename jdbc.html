<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="Ressources pédagogiques pour le MOOC Java EE Spring prêt à l'emploi">
    <meta name="author" content="Guillaume Dufrêne, Lionel Seinturier, Julien Wittouck">
    
    <link rel="stylesheet" href="bootstrap/bootstrap.min.css">
    <link rel="stylesheet" href="bootstrap/ie10-viewport-bug-workaround.css">
    <link rel="stylesheet" href="css/main.css">
    <link href="https://fonts.googleapis.com/css?family=Muli" rel="stylesheet">
  </head>
  <body>


<!-- Fixed navbar -->
 <nav class="navbar navbar-default navbar-fixed-top">
   <div class="container">
     <div class="navbar-header">
       <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
         <span class="sr-only">Toggle navigation</span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
       </button>
       <a class="navbar-brand" href="index.html">Java EE Spring ////</a>
     </div>
     <div id="navbar" class="navbar-collapse collapse">
       <div class="nav navbar-nav subtitle hidden-xs">Prêt à l'emploi</div>
       <ul class="nav navbar-nav navbar-right">
         <li>
           <a href="index.html">Accueil</a>
         </li><li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
             Outils <span class="caret"></span>
           </a>
           <ul class="dropdown-menu">
             <li><a href="git.html">Git</a></li>
             <li><a href="maven.html">Maven</a></li>
             <li><a href="docker.html">Docker</a></li>
           </ul>
         </li><li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                Java EE <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <li><a href="java.html">Java</a></li>
                <li><a href="tomcat.html">Tomcat</a></li>
                <li><a href="servlet.html">Servlet / JSP</a></li>
                <li><a href="jstl.html">JSTL</a></li>
                <li><a href="jdbc.html">JDBC</a></li>
                <li><a href="jpa.html">JPA</a></li>
              </ul>
         </li><li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                 Spring <span class="caret"></span>
               </a>
               <ul class="dropdown-menu">
                 <li><a href="spring.html">Context - IoC</a></li>
                 <li><a href="spring-mvc.html">Web MVC</a></li>
                 <li><a href="jstl.html#spring-form">JSTL taglib</a></li>
                 <li><a href="spring-mvc.html#spring-orm">ORM</a></li>
                 <li><a href="spring-data.html">Spring Data</a></li>
                 <li><a href="#">Spring Boot</a></li>
               </ul>
          </li>
       </ul>
     </div><!--/.nav-collapse -->
   </div>
   <div class="clear"></div>
 </nav>


<div class="container">
<h2><a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>JDBC</h2>

<p>
  Il y a fort longtemps dans une galaxie lointaine ... lorsque l'on souhaitait accéder à une base de données relationnelle, on utilisait un driver spécifique pour LA base de données visée et on écrivait du code SQL spécifique (car le SQL n'était pas encore très standardisé). On utilisait également des opérations spécifiques du driver.
</p>

<p>
  Puis est arrivé JDBC ... une abstraction Java permettant de standardiser un peu les méthodes qui manipulent ces bases. JDBC est une spécification : des interfaces et des objets disponibles dans le package java.sql.
</p>

<p>
  Il reste nécessaire d'avoir le driver de la base de données compatible JDBC, mais vous devriez être capable de changer de driver (et donc de base de données) sans avoir à modifier trop de choses dans votre code.
</p>

<p>
La vidéo suivante est une présentation générale de JDBC.
</p>

<p align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/W5yvqvxnRYk?rel=0" frameborder="0" allowfullscreen=""></iframe>
</p>

<p align="center">
<a href="pdf/2.1_jdbc.pdf">Transparents présentés dans la vidéo</a>
</p>


<p>
Ci dessous une explications pour chaque élément de JDBC présenté dans la vidéo.
</p>


<h3>DriverManager</h3>

<p>
  Les implémentations de JDBC se présentent sous la forme d'un fichier jar à mettre dans le classpath.<br/>
  Ces librairies ne sont normalement pas nécessaires lors de la compilation, l'idée étant de pouvoir en changer facilement sans recompiler les sources.
</p>

<p>
  Les drivers s'enregistrent auprès d'un objet DriverManager. Cela se fait normalement au chargement de la classe du driver.<br/>
  Dans des sources Java, vous pourriez trouver quelque chose du type :
  
<pre>
  Class.forName("org.mysql.Driver");
</pre>

Il n'y a donc pas de dépendance directe vers la classe du driver, c'est une chaîne de caractères vue par le compilateur. Le chargement de la classe se fait au moment de l'exécution du code (au runtime).
</p>

<p>
  Le DriverManager va associer un nom de driver à cette librairie, ce qui permettra de faire le lien lors de l'ouverture de connexion.
<p>
  
<h3>Connexion</h3>

<p>
  La connexion à la base de données se fait avec une URL dont le format sera : <code>jdbc:driver:xxx</code>.<br/>
  Selon les spécifications, l'URL commence nécessairement par jdbc.<br/>
  Le nom du driver sera par exemple : mysql, sqlite, postgresql ...<br/>
  La dernière partie de l'URL est dépendante du driver mais sera souvent du type : <code>//serveur:port/dbName?options</code>.
  Les connexions aux bases de données se font généralement en TCP sur un port défini dans l'URL, ou le port par défaut du driver. Le serveur est désigné par son IP ou son adresse connue du DNS. <br/>
  dbName est le nom de la base de données à utiliser.<br/>
  De nombreux drivers proposent également la possibilité de mettre des options à la suite sous la même forme que dans une URL web : <code>?cle=valeur&amp;cle2=valeur2</code>.<br/>
  Une gestion des utilisateurs est également souvent proposée dans les systèmes de base de données.<br/>
  Au moment de l'ouverture de connexion, vous pouvez donc préciser un utilisateur et un mot de passe.<br/>
</p>

<p>
  L'ouverture de connexion peut se faire sur l'objet DriverManager :
</p>

<pre>
  Class.forName("org.mysql.Driver");
  Connection connection = DriverManager.getConnection("jdbc:mysql://localhost/baseTest", "user", "password");
</pre>

<p>
  ou en utilisant un objet DataSource. 
</p>

<pre>
  SQLiteDataSource ds = new SQLiteDataSource();
  ds.setUrl("jdbc:sqlite:data.db");
  Connection conn = ds.getConnection();
</pre>

<p>
  Dans ce dernier cas le driver est nécessaire à la compilation puisque l'objet SQLiteDataSource qui implémente DataSource  est présent dans les sources.
</p>

<h3>SQLException</h3>

<p>
  La plupart des opérations sur la base de données peuvent lancer une SQLException. Vous devez donc placer ces opérations dans un try et réaliser un traitement approprié dans le catch, ou transformer cette exception technique en une exception ayant un sens plus "métier".<br/>
  Par exemple, lors de l'ajout d'un utilisateur, si une contrainte de clé primaire n'est pas respectée, cela lève une erreur SQL qui peut être traduite en erreur "métier" : "cet utilisateur existe déjà" ; que ce soit par un code d'erreur ou une autre exception.
</p>

<p>
  Il n'est pas facile de déterminer quelle erreur technique est survenue. Cela passe souvent par un code d'erreur spécifique à la base de donnée utilisée ... <br/>
  On préfère donc faire une vérification en base via une autre requête avant d'essayer d'insérer ou mettre à jour une données qui ne serait pas valide.<br/>
  Dans le cas de notre ajout d'utilisateur il faudrait donc vérifier que la clé primaire n'est pas déjà utilisée (son login, ou son mail ...).<br/>
  Les exceptions SQLException ne devraient pas remontées au delà de vos DAO.
</p>

<h3>Requêtes</h3>

<p>
  Il y a deux grands types de requêtes : 
<ul>
  <li>Celles qui renvoient des tuples (select)</li>
  <li>Celles qui mettent à jour des données (insert, update, delete)</li>
</ul>

Dans les deux cas il faut d'abord obtenir un objet "<b>Statement</b>" depuis la connexion, sur lequel on fera une opération executeQuery ou executeUpdate.<br/>
</p>

<p>
  Les requêtes de sélection renvoient un "<b>ResultSet</b>", c'est un curseur permettant de récupérer les données de la base, ligne par ligne.<br/>
  Il faut faire avancer ce curseur avec l'opération "next" jusqu'à ce qu'il renvoie "false".<br/>
  Cela ce manipule donc de la même manière qu'un Itérateur, souvent dans une boucle <code>while( rs.next() )</code>.<br/>
  C'est le ResultSet qui permet d'accéder à chaque valeur de tuple avec des opérations de type <code>rs.getString(X)</code>.<br/>
  X est soit un entier entre 1 et le nombre de colonnes du résultat, soit une chaîne de caractères désignant le nom de la colonne.<br/>
  Il existe différents getters (getString, getInt, getDate, getDouble) permettant de récupérer un type compatible avec la variable Java à affecter.<br/>
</p>

<p>
  Un exemple de sélection pourra ressembler à cela :
</p>

<pre>
ResultSet rs = connection
	.createStatement()
	.executeQuery(
		"select firstname, lastname, avg(note) as moyenne "
		+ "from students inner join scores using student_id group by scores.student_id"
	); 

while( rs.next() ) {
	String prenom = rs.getString("firstname");
	String nom = rs.getString("firstname");
	double moyenne = rs.getDouble(3);
	
	if ( moyenne &lt; 10.0 ) System.out.println( prenom + " " + nom + ", moyenne : " + moyenne);
}
</pre>

<h3>PreparedStatement</h3>

<p>
  La vidéo suivante présente les requêtes préparées.
</p>

<p align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZgYLf-_SC-U?rel=0" frameborder="0" allowfullscreen=""></iframe>
</p>

<p align="center">
<a href="pdf/2.2_prepared_statement.pdf">Transparents présentés dans la vidéo</a>
</p>


<p>
  Illustrons l'usage d'une requête préparée par une mise en situation mettant en avant l'importance de filtrée les paramètres de l'utilisateur.<br/>
  Rappelez-vous que les requêtes se construisent à partir d'une chaîne de caractères qui est ensuite interprétée par la base de données.<br/>
</p>


<pre>
  String paramUniv = ...; // un paramètre saisi par l'utilisateur
  ResultSet rs = connection
  	.createStatement()
  	.executeQuery(
  		<font color="blue">"select date_examen, note from diplomes where universite = '"</font> + <font color="red">paramUniv</font> + <font color="blue">"' "</font>
  		+ <font color="blue">"and diplome = 'licence-info' and student_id = "</font> + <font color="red">studentId</font>
  	);
</pre>

<p>
  Supposons qu'il s'agisse d'une application permettant à un étudiant de s'inscrire en master en fonction de ses notes en licence.
  Si le paramètre "paramMatiere" est saisi par l'utilisateur, rien ne l'empêche de saisir <code>LILLE1' and student_id = 123456 OR '1' = '0</code>. On obtient alors une requête valide qui retourne les notes d'un autre étudiant ...<br/>
  Il est donc indispensable de filtrer les paramètres saisis par un utilisateur que l'on souhaite ajouter à notre requête SQL.<br/>
</p>

<p>
  JDBC fournit la possibilité de faire des requêtes préparées et d'y substituer un ensemble de valeurs qui seront correctement échappées en fonction de leur type. Ce sont les <b>PreparedStatement</b> qui s'obtiennent sur l'objet connexion également.<br/>
  La requête doit contenir des "<b>?</b>" qui sont remplacés par une valeur avec les opérations setString, setDate, setDouble ...<br/>
  Une fois les paramètres affectés, il suffit de réaliser le "executeUpdate" ou "executeQuery" sur le preparedStatement <span style="color: red">sans paramètre</span>.<br/>
  exemple : 
</p>

<pre>
	String email = "";
	
	PreparedStatement ps = connection.prepareStatement("select * from user where email = ?");
	ps.setString(1, email);
	ResultSet rs = ps.executeQuery();
	// ...
</pre>


<h3>ResultSetMetaData</h3>

<p>
  Il peut être intéressant de connaitre le nombre de colonnes et les types retournés par la base de données sur l'exécution d'une requête ; par exemple à la suite d'un "select *". <br/>
  Cela peut se faire à l'aide de l'objet <b>ResultSetMetaData</b> qui s'obtient sur un ResultSet. Cette opération peut se faire avant même d'avoir fait le premier "rs.next()".<br/>
  De cette manière il peut être possible de générer des tableaux html dynamiques en fonction du contenu des tables par exemple.
</p>

<pre>
	PreparedStatement ps = connection.prepareStatement("select * from user");
	ResultSet rs = ps.executeQuery();
	ResultSetMetaData meta = rs.getMetaData();
	for ( int i = 1; i &lt;= meta.getColumnCount(); i++ ) {
		System.out.println("Colonne : " + meta.getColumnName(i));
		System.out.println("  Type  : " + meta.getColumnTypeName(i));
	}
</pre>
<h2><a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a><a name="servlet"></a>DAO</h2>

<p>
La vidéo suivante présente le patron de conception "Data Access Object" (DAO).<br/>
</p>

<p align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/Ty8414r7Bmk?rel=0" frameborder="0" allowfullscreen=""></iframe>
</p>

<p align="center">
<a href="pdf/2.4_dao.pdf">Transparents présentés dans la vidéo</a>
</p>

<p>
Le screencast suivant implémente un DAO en JDBC et montre comment l'utiliser avec une JSP.<br/>
</p>

<p align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/hUk4JXJTmjM?rel=0" frameborder="0" allowfullscreen=""></iframe>
</p>

    <footer>
      <p>
        <img align="right" src="img/UL-2014.png" height="80"/>
        Projet réalisé par 
        <a href="https://github.com/gdufrene">
          Guillaume Dufrêne</a>, 
        <a href="http://www.lifl.fr/~seinturi/">
          Lionel Seinturier</a>,
        <a href="https://github.com/juwit">
          Julien Wittouck</a>
        - Université de Lille
        <br/>
        Hosted on GitHub Pages &mdash; Theme by <a href="http://semm.univ-lille1.fr/">SEMM</a> / B. Dufrêne
      </p>
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
          <img style="float: left, margin: 10px" alt="Licence Creative Commons" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png" />
        </a>
        Cette œuvre est mise à disposition selon les termes de la Licence :<br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
          Creative Commons Attribution <br/>
          - Pas d’Utilisation Commerciale <br/>
          - Partage dans les Mêmes Conditions <br/>
          4.0 International</a>.
      </p>
    </footer>
    
</div> <!-- container -->

    <script src="bootstrap/jquery.min.js"></script>
    <script src="bootstrap/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="bootstrap/ie10-viewport-bug-workaround.js"></script>
    
  </body>
</html>
